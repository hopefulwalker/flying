        // headerClass, varHeader, varBytes, msgTypeClass, replyClass, exception, varReply, msgDTOClass, varMsgDTO, dtoClass,
        // stringContained, varDTOFields, varDTOs, retKindName
        // Send and Receive the report message before timeout
        @{headerClass} @{varHeader} = new @{headerClass}();
        DirectBuffer replyBuffer = new DirectBuffer(@{varBytes});
        @{varHeader}.wrap(replyBuffer, 0, 0);
        if (@{varHeader}.msgType() != @{msgTypeClass}.@{replyClass}) {
            throw new @{exception}(@{exception}.MISMATCH_REPLY, "expected:" + @{msgTypeClass}.@{replyClass} + "actual:" + @{varHeader}.msgType());
        }
        @{replyClass} @{varReply} = new @{replyClass}();
        @{varReply}.wrapForDecode(replyBuffer, @{varHeader}.size(), @{varHeader}.blockLength(), @{varHeader}.version());
        if (@{varReply}.retCode() != IReturnCode.SUCCESS) {
            throw new @{exception}(@{varReply}.retCode());
        }
        // Analyze the reply and build the list of server bos.
        @{replyClass}.@{msgDTOClass} @{varMsgDTO} = @{varReply}.@{varMsgDTO}();
        if (@{varMsgDTO}.count() <= 0) return null;
        @{retKindName} @{varDTOs} = new ArrayList<>();
        @{dtoClass} @{varDTO};
        while (@{varMsgDTO}.hasNext()) {
            @if{stringContained} try { @end{}
                @{varMsgDTO}.next();
                @{varDTO} = new @{dtoClass}();
                @{varDTOFields}
                @{varDTOs}.add(@{varDTO});
            @if{stringContained}} catch (UnsupportedEncodingException uee) {
                throw new @{exception}(@{exception}.FAILED_TO_BUILD_REPLY, uee);
            }@end{}
        }
        return @{varDTOs};